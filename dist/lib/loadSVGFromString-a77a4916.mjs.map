{"version":3,"file":"loadSVGFromString-a77a4916.mjs","sources":["../../src/extension/parser/applyViewboxTransform.ts","../../src/extension/parser/hasInvalidAncestor.ts","../../src/extension/parser/elementById.ts","../../src/extension/parser/getMultipleNodes.ts","../../src/extension/parser/parseUseDirectives.ts","../../src/extension/util/transform_matrix_removal.ts","../../src/extension/parser/recursivelyParseGradientsXlink.ts","../../src/extension/parser/getGradientDefs.ts","../../src/extension/parser/getCSSRules.ts","../../src/extension/object/IText.ts","../../src/extension/parser/elements_parser.ts","../../src/extension/parser/parseSVGDocument.ts","../../src/extension/parser/loadSVGFromString.ts"],"sourcesContent":["import { svgNS } from './constants';\nimport {\n  parsePreserveAspectRatioAttribute,\n  parseUnit,\n} from '../util/misc/svgParsing';\nimport { svgViewBoxElementsRegEx, reViewBoxAttrValue } from './constants';\nimport { NONE } from '../constants';\n\nexport type ParsedViewboxTransform = Partial<{\n  width: number;\n  height: number;\n  minX: number;\n  minY: number;\n  viewBoxWidth: number;\n  viewBoxHeight: number;\n}>;\n\n/**\n * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements\n */\nexport function applyViewboxTransform(\n  element: Element\n): ParsedViewboxTransform {\n  if (!svgViewBoxElementsRegEx.test(element.nodeName)) {\n    return {};\n  }\n  const viewBoxAttr: string | null = element.getAttribute('viewBox');\n  let scaleX = 1;\n  let scaleY = 1;\n  let minX = 0;\n  let minY = 0;\n  let matrix;\n  let el;\n  const widthAttr = element.getAttribute('width');\n  const heightAttr = element.getAttribute('height');\n  const x = element.getAttribute('x') || 0;\n  const y = element.getAttribute('y') || 0;\n  const goodViewbox = viewBoxAttr && reViewBoxAttrValue.test(viewBoxAttr);\n  const missingViewBox = !goodViewbox;\n  const missingDimAttr =\n    !widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%';\n\n  let translateMatrix = '';\n  let widthDiff = 0;\n  let heightDiff = 0;\n\n  if (missingViewBox) {\n    if (\n      (x || y) &&\n      element.parentNode &&\n      element.parentNode.nodeName !== '#document'\n    ) {\n      translateMatrix =\n        ' translate(' + parseUnit(x || '0') + ' ' + parseUnit(y || '0') + ') ';\n      matrix = (element.getAttribute('transform') || '') + translateMatrix;\n      element.setAttribute('transform', matrix);\n      element.removeAttribute('x');\n      element.removeAttribute('y');\n    }\n  }\n\n  if (missingViewBox && missingDimAttr) {\n    return {\n      width: 0,\n      height: 0,\n    };\n  }\n\n  const parsedDim: ParsedViewboxTransform = {\n    width: 0,\n    height: 0,\n  };\n\n  if (missingViewBox) {\n    parsedDim.width = parseUnit(widthAttr!);\n    parsedDim.height = parseUnit(heightAttr!);\n    // set a transform for elements that have x y and are inner(only) SVGs\n    return parsedDim;\n  }\n\n  const pasedViewBox = viewBoxAttr.match(reViewBoxAttrValue)!;\n  minX = -parseFloat(pasedViewBox[1]);\n  minY = -parseFloat(pasedViewBox[2]);\n  const viewBoxWidth = parseFloat(pasedViewBox[3]);\n  const viewBoxHeight = parseFloat(pasedViewBox[4]);\n  parsedDim.minX = minX;\n  parsedDim.minY = minY;\n  parsedDim.viewBoxWidth = viewBoxWidth;\n  parsedDim.viewBoxHeight = viewBoxHeight;\n  if (!missingDimAttr) {\n    parsedDim.width = parseUnit(widthAttr);\n    parsedDim.height = parseUnit(heightAttr);\n    scaleX = parsedDim.width / viewBoxWidth;\n    scaleY = parsedDim.height / viewBoxHeight;\n  } else {\n    parsedDim.width = viewBoxWidth;\n    parsedDim.height = viewBoxHeight;\n  }\n\n  // default is to preserve aspect ratio\n  const preserveAspectRatio = parsePreserveAspectRatioAttribute(\n    element.getAttribute('preserveAspectRatio') || ''\n  );\n  if (preserveAspectRatio.alignX !== NONE) {\n    //translate all container for the effect of Mid, Min, Max\n    if (preserveAspectRatio.meetOrSlice === 'meet') {\n      scaleY = scaleX = scaleX > scaleY ? scaleY : scaleX;\n      // calculate additional translation to move the viewbox\n    }\n    if (preserveAspectRatio.meetOrSlice === 'slice') {\n      scaleY = scaleX = scaleX > scaleY ? scaleX : scaleY;\n      // calculate additional translation to move the viewbox\n    }\n    widthDiff = parsedDim.width - viewBoxWidth * scaleX;\n    heightDiff = parsedDim.height - viewBoxHeight * scaleX;\n    if (preserveAspectRatio.alignX === 'Mid') {\n      widthDiff /= 2;\n    }\n    if (preserveAspectRatio.alignY === 'Mid') {\n      heightDiff /= 2;\n    }\n    if (preserveAspectRatio.alignX === 'Min') {\n      widthDiff = 0;\n    }\n    if (preserveAspectRatio.alignY === 'Min') {\n      heightDiff = 0;\n    }\n  }\n\n  if (\n    scaleX === 1 &&\n    scaleY === 1 &&\n    minX === 0 &&\n    minY === 0 &&\n    x === 0 &&\n    y === 0\n  ) {\n    return parsedDim;\n  }\n  if ((x || y) && element.parentNode!.nodeName !== '#document') {\n    translateMatrix =\n      ' translate(' + parseUnit(x || '0') + ' ' + parseUnit(y || '0') + ') ';\n  }\n\n  matrix =\n    translateMatrix +\n    ' matrix(' +\n    scaleX +\n    ' 0' +\n    ' 0 ' +\n    scaleY +\n    ' ' +\n    (minX * scaleX + widthDiff) +\n    ' ' +\n    (minY * scaleY + heightDiff) +\n    ') ';\n  // seems unused.\n  // parsedDim.viewboxTransform = parseTransformAttribute(matrix);\n  if (element.nodeName === 'svg') {\n    el = element.ownerDocument.createElementNS(svgNS, 'g');\n    // element.firstChild != null\n    while (element.firstChild) {\n      el.appendChild(element.firstChild);\n    }\n    element.appendChild(el);\n  } else {\n    el = element;\n    el.removeAttribute('x');\n    el.removeAttribute('y');\n    matrix = el.getAttribute('transform') + matrix;\n  }\n  el.setAttribute('transform', matrix);\n  return parsedDim;\n}\n","import { svgInvalidAncestors } from './constants';\nimport { getSvgRegex } from './getSvgRegex';\n\nconst svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);\n\nexport function hasInvalidAncestor(element: Element) {\n  let _element: Element | null = element;\n  while (_element && (_element = _element.parentElement)) {\n    if (\n      _element &&\n      _element.nodeName &&\n      svgInvalidAncestorsRegEx.test(_element.nodeName.replace('svg:', '')) &&\n      !_element.getAttribute('instantiated_by_use')\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n","/**\n * @private\n * TODO: verify if this is still needed\n * to support IE8 missing getElementById on SVGdocument and on node xmlDOM\n */\nexport function elementById(doc: Document, id: string): Element | null {\n  if (doc.getElementById) {\n    return doc.getElementById(id);\n  }\n  const nodelist = doc.getElementsByTagName('*');\n  for (let i = 0, len = nodelist.length; i < len; i++) {\n    const node = nodelist[i];\n    if (id === node.getAttribute('id')) {\n      return node;\n    }\n  }\n  return null;\n}\n","export function getMultipleNodes(\n  doc: Document,\n  nodeNames: string[]\n): Element[] {\n  let nodeName,\n    nodeArray: Element[] = [],\n    nodeList,\n    i,\n    len;\n  for (i = 0, len = nodeNames.length; i < len; i++) {\n    nodeName = nodeNames[i];\n    nodeList = doc.getElementsByTagNameNS(\n      'http://www.w3.org/2000/svg',\n      nodeName\n    );\n    nodeArray = nodeArray.concat(Array.from(nodeList));\n  }\n  return nodeArray;\n}\n","import { svgNS } from './constants';\nimport { elementById } from './elementById';\nimport { getMultipleNodes } from './getMultipleNodes';\nimport { applyViewboxTransform } from './applyViewboxTransform';\n\nexport function parseUseDirectives(doc: Document) {\n  const nodelist = getMultipleNodes(doc, ['use', 'svg:use']);\n  let i = 0;\n  while (nodelist.length && i < nodelist.length) {\n    const el = nodelist[i],\n      xlinkAttribute = el.getAttribute('xlink:href') || el.getAttribute('href');\n\n    if (xlinkAttribute === null) {\n      return;\n    }\n\n    const xlink = xlinkAttribute.slice(1);\n    const x = el.getAttribute('x') || 0;\n    const y = el.getAttribute('y') || 0;\n    if(!elementById(doc, xlink)){\n      return;\n    }\n    let el2 = elementById(doc, xlink)!.cloneNode(true) as Element;\n    let currentTrans =\n      (el2.getAttribute('transform') || '') +\n      ' translate(' +\n      x +\n      ', ' +\n      y +\n      ')';\n    const oldLength = nodelist.length;\n    const namespace = svgNS;\n\n    applyViewboxTransform(el2);\n    if (/^svg$/i.test(el2.nodeName)) {\n      const el3 = el2.ownerDocument.createElementNS(namespace, 'g');\n      for (\n        let j = 0, attrs = el2.attributes, len = attrs.length;\n        j < len;\n        j++\n      ) {\n        const attr: Attr | null = attrs.item(j);\n        attr && el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue!);\n      }\n      // el2.firstChild != null\n      while (el2.firstChild) {\n        el3.appendChild(el2.firstChild);\n      }\n      el2 = el3;\n    }\n\n    for (let j = 0, attrs = el.attributes, len = attrs.length; j < len; j++) {\n      const attr = attrs.item(j);\n      if (!attr) {\n        continue;\n      }\n      const { nodeName, nodeValue } = attr;\n      if (\n        nodeName === 'x' ||\n        nodeName === 'y' ||\n        nodeName === 'xlink:href' ||\n        nodeName === 'href'\n      ) {\n        continue;\n      }\n\n      if (nodeName === 'transform') {\n        currentTrans = nodeValue + ' ' + currentTrans;\n      } else {\n        el2.setAttribute(nodeName, nodeValue!);\n      }\n    }\n\n    el2.setAttribute('transform', currentTrans);\n    el2.setAttribute('instantiated_by_use', '1');\n    el2.removeAttribute('id');\n    const parentNode = el.parentNode;\n    parentNode!.replaceChild(el2, el);\n    // some browsers do not shorten nodelist after replaceChild (IE8)\n    if (nodelist.length === oldLength) {\n      i++;\n    }\n  }\n}\n","import { CENTER } from '../constants';\nimport type { Image, Object as FabricObject, TMat2D } from 'fabric';\nimport { qrDecompose } from './misc/matrix';\n\ntype FabricObjectWithTransformMatrix = FabricObject & {\n  transformMatrix?: TMat2D;\n};\n\n/**\n * This function is an helper for svg import. it decompose the transformMatrix\n * and assign properties to object.\n * untransformed coordinates\n * @private\n */\nconst _assignTransformMatrixProps = (\n  object: FabricObjectWithTransformMatrix\n) => {\n  if (object.transformMatrix) {\n    const { scaleX, scaleY, angle, skewX } = qrDecompose(\n      object.transformMatrix\n    );\n    object.flipX = false;\n    object.flipY = false;\n    object.set('scaleX', scaleX);\n    object.set('scaleY', scaleY);\n    object.angle = angle;\n    object.skewX = skewX;\n    object.skewY = 0;\n  }\n};\n\n/**\n * This function is an helper for svg import. it removes the transform matrix\n * and set to object properties that fabricjs can handle\n * @private\n * @param {Object} preserveAspectRatioOptions\n */\nexport const removeTransformMatrixForSvgParsing = (\n  object: FabricObjectWithTransformMatrix,\n  preserveAspectRatioOptions?: any\n) => {\n  let center = object._findCenterFromElement();\n  if (object.transformMatrix) {\n    _assignTransformMatrixProps(object);\n    center = center.transform(object.transformMatrix);\n  }\n  delete object.transformMatrix;\n  if (preserveAspectRatioOptions) {\n    object.scaleX *= preserveAspectRatioOptions.scaleX;\n    object.scaleY *= preserveAspectRatioOptions.scaleY;\n    (object as Image).cropX = preserveAspectRatioOptions.cropX;\n    (object as Image).cropY = preserveAspectRatioOptions.cropY;\n    center.x += preserveAspectRatioOptions.offsetLeft;\n    center.y += preserveAspectRatioOptions.offsetTop;\n    object.width = preserveAspectRatioOptions.width;\n    object.height = preserveAspectRatioOptions.height;\n  }\n  object.setPositionByOrigin(center, CENTER, CENTER);\n};\n","import { elementById } from './elementById';\n\nconst gradientsAttrs = [\n  'gradientTransform',\n  'x1',\n  'x2',\n  'y1',\n  'y2',\n  'gradientUnits',\n  'cx',\n  'cy',\n  'r',\n  'fx',\n  'fy',\n];\nconst xlinkAttr = 'xlink:href';\n\nexport function recursivelyParseGradientsXlink(\n  doc: Document,\n  gradient: Element\n) {\n  const xLink = gradient.getAttribute(xlinkAttr)?.slice(1) || '',\n    referencedGradient = elementById(doc, xLink);\n  if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {\n    recursivelyParseGradientsXlink(doc, referencedGradient as Element);\n  }\n  if (referencedGradient) {\n    gradientsAttrs.forEach((attr) => {\n      const value = referencedGradient.getAttribute(attr);\n      if (!gradient.hasAttribute(attr) && value) {\n        gradient.setAttribute(attr, value);\n      }\n    });\n    if (!gradient.children.length) {\n      const referenceClone = referencedGradient.cloneNode(true);\n      while (referenceClone.firstChild) {\n        gradient.appendChild(referenceClone.firstChild);\n      }\n    }\n  }\n  gradient.removeAttribute(xlinkAttr);\n}\n","import { getMultipleNodes } from './getMultipleNodes';\nimport { recursivelyParseGradientsXlink } from './recursivelyParseGradientsXlink';\n\nconst tagArray = [\n  'linearGradient',\n  'radialGradient',\n  'svg:linearGradient',\n  'svg:radialGradient',\n];\n\n/**\n * Parses an SVG document, returning all of the gradient declarations found in it\n * @param {SVGDocument} doc SVG document to parse\n * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element\n */\nexport function getGradientDefs(\n  doc: Document\n): Record<string, SVGGradientElement> {\n  const elList = getMultipleNodes(doc, tagArray);\n  const gradientDefs: Record<string, SVGGradientElement> = {};\n  let j = elList.length;\n  while (j--) {\n    const el = elList[j];\n    if (el.getAttribute('xlink:href')) {\n      recursivelyParseGradientsXlink(doc, el);\n    }\n    const id = el.getAttribute('id');\n    if (id) {\n      gradientDefs[id] = el as SVGGradientElement;\n    }\n  }\n  return gradientDefs;\n}\n","import type { CSSRules } from './typedefs';\n\n/**\n * Returns CSS rules for a given SVG document\n * @param {HTMLElement} doc SVG document to parse\n * @return {Object} CSS rules of this document\n */\nexport function getCSSRules(doc: Document) {\n  const styles = doc.getElementsByTagName('style');\n  let i;\n  let len;\n  const allRules: CSSRules = {};\n\n  // very crude parsing of style contents\n  for (i = 0, len = styles.length; i < len; i++) {\n    const styleContents = (styles[i].textContent || '').replace(\n      // remove comments\n      /\\/\\*[\\s\\S]*?\\*\\//g,\n      ''\n    );\n\n    if (styleContents.trim() === '') {\n      continue;\n    }\n    // recovers all the rule in this form `body { style code... }`\n    // rules = styleContents.match(/[^{]*\\{[\\s\\S]*?\\}/g);\n    styleContents\n      .split('}')\n      // remove empty rules.\n      .filter(function (rule) {\n        return rule.trim();\n      })\n      // at this point we have hopefully an array of rules `body { style code... `\n      // eslint-disable-next-line no-loop-func\n      .forEach(function (rule) {\n        const match = rule.split('{'),\n          ruleObj: Record<string, string> = {},\n          declaration = match[1].trim(),\n          propertyValuePairs = declaration.split(';').filter(function (pair) {\n            return pair.trim();\n          });\n\n        for (i = 0, len = propertyValuePairs.length; i < len; i++) {\n          const pair = propertyValuePairs[i].split(':'),\n            property = pair[0].trim(),\n            value = pair[1].trim();\n          ruleObj[property] = value;\n        }\n        rule = match[0].trim();\n        rule.split(',').forEach((_rule) => {\n          _rule = _rule.replace(/^svg/i, '').trim();\n          if (_rule === '') {\n            return;\n          }\n          allRules[_rule] = {\n            ...(allRules[_rule] || {}),\n            ...ruleObj,\n          };\n        });\n      });\n  }\n  return allRules;\n}\n","import { IText as OriginIText, classRegistry, Text } from \"fabric\"\nimport { EffectItem } from \"@/types/common\"\nimport type { Abortable } from 'fabric'\nimport { CENTER, RIGHT, LEFT, DEFAULT_SVG_FONT_SIZE } from \"../constants\"\nimport { parseAttributes } from '../parser/parseAttributes'\nimport {ArcTextMixin} from \"@/extension/mixins/arctext.mixin\";\nimport {ArcText} from \"@/extension/object/ArcText\";\nimport {TextMixin} from \"@/extension/mixins/text.mixin\";\n\nexport class IText extends OriginIText {\n  public effects?: EffectItem[];\n\n  constructor(text: string, options?: any) {\n    super(text, options);\n    this.effects = options.effects\n    this.on('mousedblclick', this.onDblClick.bind(this))\n  }\n\n  renderEffects() {\n    console.log('renderEffects:')\n    this.canvas?.renderAll()\n  }\n\n  _renderChar(method: \"fillText\" | \"strokeText\", ctx: CanvasRenderingContext2D, lineIndex: number, charIndex: number, _char: string, left: number, top: number): void {\n    if (this.effects) {\n      // for (let i = 0; i < this.effects.length; i++) {\n      for (let i = this.effects.length - 1; i >= 0; i--) {\n        const item = this.effects[i]\n        ctx.save();\n        ctx.strokeStyle = item.stroke;\n        ctx.lineJoin = item.strokeLineJoin;\n        ctx.lineWidth = item.strokeWidth;\n        ctx.strokeText(_char, left, top);\n        ctx.restore()\n      }\n    }\n    super._renderChar(method, ctx, lineIndex, charIndex, _char, left, top)\n  }\n\n  static async fromElement(\n    element: HTMLElement,\n    options?: Abortable,\n    cssRules?: any\n  ) {\n    const parsedAttributes = parseAttributes(\n      element,\n      Text.ATTRIBUTE_NAMES,\n      cssRules\n    );\n    const {\n      textAnchor = LEFT as typeof LEFT | typeof CENTER | typeof RIGHT,\n      textDecoration = '',\n      dx = 0,\n      dy = 0,\n      top = 0,\n      left = 0,\n      fontSize = DEFAULT_SVG_FONT_SIZE,\n      strokeWidth = 1,\n      ...restOfOptions\n    } = { ...options, ...parsedAttributes };\n\n    const textContent = (element.textContent || '')\n    // const textContent = (element.textContent || '')\n    //   .replace(/^\\s+|\\s+$|\\n+/g, '')\n    //   .replace(/\\s+/g, ' ');\n\n    // this code here is probably the usual issue for SVG center find\n    // this can later looked at again and probably removed.\n\n    function isPunctuationOrSymbol(code) {\n      // Sử dụng Set cho các ký tự lẻ và mảng cho các khoảng liên tiếp\n      const singleCodePoints = new Set([\n        0x005F, 0x00BB, 0x2019, 0x201D, 0x203A, 0x00AB, 0x2018, 0x201B, 0x201C, 0x201F, 0x2039,\n        0x2022, 0x00B7, 0x2219, 0x25CF // Bullet, Middle Dot, Bullet Operator, Black Circle\n        // Thêm các mã đơn lẻ khác tại đây nếu cần\n      ]);\n\n      const ranges = [\n        [0x0021, 0x0023], [0x0025, 0x002A], [0x002C, 0x002F], // Basic Punctuation\n        [0x003A, 0x003B], [0x003F, 0x0040], // Colon, Semicolon, Question Mark, At Sign\n        [0x2010, 0x2015], // Hyphen, Non-breaking Hyphen, Figure Dash, En Dash, Em Dash, Horizontal Bar\n        [0x203F, 0x2040], // Undertie, Character Tie\n        [0x2300, 0x23FF], // Miscellaneous Technical\n        [0x20A0, 0x20CF], // Currency Symbols\n        [0x2200, 0x22FF], // Mathematical Operators\n        [0x25A0, 0x25FF], // Geometric Shapes\n        [0x2600, 0x26FF], // Miscellaneous Symbols\n        [0x27C0, 0x27EF], // Miscellaneous Mathematical Symbols-A\n        [0x27F0, 0x27FF], // Supplemental Arrows-A\n        [0x2900, 0x297F], // Supplemental Arrows-B\n        [0x2980, 0x29FF], // Miscellaneous Mathematical Symbols-B\n        [0x2A00, 0x2AFF], // Supplemental Mathematical Operators\n        [0x2B00, 0x2BFF], // Miscellaneous Symbols and Arrows\n        [0x2000, 0x206F], // General Punctuation\n        [0x2100, 0x214F], // Letterlike Symbols\n        [0x2190, 0x21FF], // Arrows\n        [0x2400, 0x243F], // Control Pictures\n        [0x2440, 0x245F], // Optical Character Recognition\n        [0x2500, 0x257F], // Box Drawing\n        [0x2580, 0x259F], // Block Elements\n        [0x2700, 0x27BF], // Dingbats\n        [0x2C60, 0x2C7F], // Latin Extended-C\n        [0x2E00, 0x2E7F]  // Supplemental Punctuation\n        // Thêm các khoảng mã Unicode khác tại đây nếu cần\n      ];\n\n      if (singleCodePoints.has(code)) {\n        return true;\n      }\n\n      // Kiểm tra xem mã Unicode có nằm trong các khoảng mã không\n      for (const range of ranges) {\n        if (code >= range[0] && code <= range[1]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    const text = new this(textContent, {\n        left: left + dx,\n        top: top + dy,\n        underline: textDecoration.includes('underline'),\n        overline: textDecoration.includes('overline'),\n        linethrough: textDecoration.includes('line-through'),\n        // we initialize this as 0\n        strokeWidth: 0,\n        fontSize,\n        editable: true,\n        ...restOfOptions,\n      }),\n      textHeightScaleFactor = text.getScaledHeight() / text.height,\n      lineHeightDiff =\n        (text.height + text.strokeWidth) * text.lineHeight - text.height,\n      scaledDiff = lineHeightDiff * textHeightScaleFactor,\n      textHeight = text.getScaledHeight() + scaledDiff;\n\n    let offX = 0;\n    /*\n      Adjust positioning:\n        x/y attributes in SVG correspond to the bottom-left corner of text bounding box\n        fabric output by default at top, left.\n    */\n    if (textAnchor === CENTER) {\n      offX = text.getScaledWidth() / 2;\n    }\n    if (textAnchor === RIGHT) {\n      offX = text.getScaledWidth();\n    }\n    text.set({\n      left: text.left - offX,\n      top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,\n      strokeWidth,\n    });\n    const code = text.text.charCodeAt(0);\n    const computerModernFonts = new Set([\n      \"cmsy10\", \"cmr10\", \"cmmi10\", \"cmmi7\", \"cmex10\", \"cmss10\", \"cmss12\",\n      \"cmtt10\", \"cmbx10\", \"cmbxsl10\", \"cmssl10\", \"cmfi10\", \"cmcsc10\",\n      \"cmvtt10\", \"cmb10\", \"cmmi12\", \"cmr12\", \"cmu10\"\n    ]);\n\n    if (computerModernFonts.has(text.fontFamily)) {\n      text.set({\n        fontFamily: 'times new roman'\n      });\n    }\n    return text;\n  }\n\n}\nObject.assign(IText.prototype, {\n  ...TextMixin\n})\nclassRegistry.setClass(IText)\nclassRegistry.setSVGClass(IText)","import {\n  invertTransform,\n  multiplyTransformMatrices,\n  qrDecompose,\n} from '../util/misc/matrix';\nimport { removeTransformMatrixForSvgParsing } from '../util/transform_matrix_removal';\nimport { CENTER } from '../constants';\nimport { getGradientDefs } from './getGradientDefs';\nimport { getCSSRules } from './getCSSRules';\nimport type { CSSRules, TSvgReviverCallback } from './typedefs';\nimport type { ParsedViewboxTransform } from './applyViewboxTransform';\nimport type { SVGOptions, Object as FabricObject } from 'fabric';\nimport type { LoadImageOptions } from '../util/misc/objectEnlive';\nimport { Gradient, Group, classRegistry, Point } from 'fabric';\nimport { Image } from '../object/Image';\nimport { IText } from '../object/IText';\nimport { Textbox } from '../object/Textbox';\nimport { nanoid } from 'nanoid';\n\nconst findTag = (el: Element) => {\n  const tag = el.tagName.toLowerCase().replace('svg:', '')\n  if (tag === 'image') return Image\n  if (tag === 'text') return IText\n  return classRegistry.getSVGClass(el.tagName.toLowerCase().replace('svg:', ''));\n}\n\ntype StorageType = {\n  fill: SVGGradientElement;\n  stroke: SVGGradientElement;\n  clipPath: Element[];\n  mask: Element[];\n};\n\ntype NotParsedFabricObject = FabricObject & {\n  fill: string;\n  stroke: string;\n  clipPath?: string;\n  mask?: string;\n  clipRule?: CanvasFillRule;\n};\n\nexport class ElementsParser {\n  declare elements: Element[];\n  declare options: LoadImageOptions & ParsedViewboxTransform;\n  declare reviver: TSvgReviverCallback | undefined;\n  declare regexUrl: RegExp;\n  declare doc: Document;\n  declare clipPaths: Record<string, Element[]>;\n  declare masks: Record<string, Element[]>;\n  declare gradientDefs: Record<string, SVGGradientElement>;\n  declare cssRules: CSSRules;\n\n  constructor(\n    elements: Element[],\n    options: LoadImageOptions & ParsedViewboxTransform,\n    reviver: TSvgReviverCallback | undefined,\n    doc: Document,\n    clipPaths: Record<string, Element[]>,\n    masks: Record<string, Element[]>\n  ) {\n    this.elements = elements;\n    this.options = options;\n    this.reviver = reviver;\n    this.regexUrl = /^url\\(['\"]?#([^'\"]+)['\"]?\\)/g;\n    this.doc = doc;\n    this.clipPaths = clipPaths;\n    this.masks = masks;\n    this.gradientDefs = getGradientDefs(doc);\n    this.cssRules = getCSSRules(doc);\n  }\n\n  parse(): Promise<Array<FabricObject | null>> {\n    return Promise.all(\n      this.elements.map((element) => this.createObject(element))\n    );\n  }\n\n  async createObject(el: Element): Promise<FabricObject | null> {\n    const klass = findTag(el);\n    if (klass) {\n      const obj: NotParsedFabricObject = await klass.fromElement(\n        el,\n        this.options,\n        this.cssRules\n      );\n      obj.set({id: nanoid(10)})\n      this.resolveGradient(obj, el, 'fill');\n      this.resolveGradient(obj, el, 'stroke');\n      if (obj instanceof Image && obj._originalElement) {\n        removeTransformMatrixForSvgParsing(\n          obj,\n          obj.parsePreserveAspectRatioAttribute()\n        );\n      } else {\n        removeTransformMatrixForSvgParsing(obj);\n      }\n      await this.resolveClipPath(obj, el);\n      await this.resolveMask(obj, el);\n      this.reviver && this.reviver(el, obj as any);\n      return obj;\n    }\n    return null;\n  }\n\n  extractPropertyDefinition(\n    obj: NotParsedFabricObject,\n    property: 'fill' | 'stroke' | 'clipPath' | 'mask',\n    storage: Record<string, StorageType[typeof property]>\n  ): StorageType[typeof property] | undefined {\n    const value = obj[property]!,\n      regex = this.regexUrl;\n    if (!regex.test(value)) {\n      return undefined;\n    }\n    // verify: can we remove the 'g' flag? and remove lastIndex changes?\n    regex.lastIndex = 0;\n    // we passed the regex test, so we know is not null;\n    const id = regex.exec(value)![1];\n    regex.lastIndex = 0;\n    // @todo fix this\n    return storage[id];\n  }\n\n  resolveGradient(\n    obj: NotParsedFabricObject,\n    el: Element,\n    property: 'fill' | 'stroke'\n  ) {\n    const gradientDef = this.extractPropertyDefinition(\n      obj,\n      property,\n      this.gradientDefs\n    ) as SVGGradientElement;\n    if (gradientDef) {\n      const opacityAttr = el.getAttribute(property + '-opacity');\n      const gradient = Gradient.fromElement(gradientDef, obj, {\n        ...this.options,\n        opacity: opacityAttr,\n      } as SVGOptions);\n      obj.set(property, gradient);\n    }\n  }\n\n  async resolveClipPath(obj: NotParsedFabricObject, usingElement: Element) {\n    const clipPathElements = this.extractPropertyDefinition(\n      obj,\n      'clipPath',\n      this.clipPaths\n    ) as Element[];\n    if (clipPathElements) {\n      const objTransformInv = invertTransform(obj.calcTransformMatrix());\n      // move the clipPath tag as sibling to the real element that is using it\n      const clipPathTag = clipPathElements[0].parentElement;\n      let clipPathOwner = usingElement;\n      while (\n        clipPathOwner.parentElement &&\n        clipPathOwner.getAttribute('clip-path') !== obj.clipPath\n      ) {\n        clipPathOwner = clipPathOwner.parentElement;\n      }\n      clipPathOwner.parentElement!.appendChild(clipPathTag!);\n      const container = await Promise.all(\n        clipPathElements.map((clipPathElement) => {\n          return findTag(clipPathElement)\n            .fromElement(clipPathElement, this.options, this.cssRules)\n            .then((enlivedClippath: NotParsedFabricObject) => {\n              removeTransformMatrixForSvgParsing(enlivedClippath);\n              enlivedClippath.fillRule = enlivedClippath.clipRule!;\n              delete enlivedClippath.clipRule;\n              return enlivedClippath;\n            });\n        })\n      );\n      const clipPath = container.length === 1 ? container[0] : new Group(container);\n      const gTransform = multiplyTransformMatrices(\n        objTransformInv,\n        clipPath.calcTransformMatrix()\n      );\n      if (clipPath.clipPath) {\n        await this.resolveClipPath(clipPath, clipPathOwner);\n      }\n      const { scaleX, scaleY, angle, skewX, translateX, translateY } = qrDecompose(gTransform);\n      clipPath.set({\n        flipX: false,\n        flipY: false,\n      });\n      clipPath.set({\n        scaleX,\n        scaleY,\n        angle,\n        skewX,\n        skewY: 0,\n      });\n      clipPath.setPositionByOrigin(\n        new Point(translateX, translateY),\n        CENTER,\n        CENTER\n      );\n      obj.clipPath = clipPath;\n    } else {\n      // if clip-path does not resolve to any element, delete the property.\n      delete obj.clipPath;\n      return;\n    }\n  }\n\n  async resolveMask(obj: NotParsedFabricObject, usingElement: Element) {\n    const maskElements = this.extractPropertyDefinition(\n      obj,\n      'mask',\n      this.masks\n    ) as Element[];\n    if (maskElements) {\n      const maskElement = maskElements[0] as HTMLElement\n      const maskImage = await Image.fromElement(maskElement)\n      let src = maskImage?.getSrc()\n      if (maskElement.tagName.toLowerCase() === 'text') {\n        const text = await IText.fromElement(maskElement)\n        src = text.toDataURL()\n      }\n      obj.set({mask: {\n        src: src,\n        left: obj.left,\n        top: obj.top,\n        width: obj.width,\n        height: obj.height\n      }})\n    }\n  }\n}\n","import { applyViewboxTransform } from './applyViewboxTransform';\nimport { svgValidTagNamesRegEx } from './constants';\nimport { hasInvalidAncestor } from './hasInvalidAncestor';\nimport { parseUseDirectives } from './parseUseDirectives';\nimport type { SVGParsingOutput, TSvgReviverCallback } from './typedefs';\nimport type { LoadImageOptions } from '../util/misc/objectEnlive';\nimport { ElementsParser } from './elements_parser';\n\nconst isValidSvgTag = (el: Element) =>\n  svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', ''));\n\nexport const createEmptyResponse = (): SVGParsingOutput => ({\n  objects: [],\n  elements: [],\n  options: {},\n  allElements: [],\n});\n\n/**\n * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\n * @static\n * @function\n * @memberOf fabric\n * @param {HTMLElement} doc SVG document to parse\n * @param {TSvgParsedCallback} callback Invoked when the parsing is done, with null if parsing wasn't possible with the list of svg nodes.\n * @param {TSvgReviverCallback} [reviver] Extra callback for further parsing of SVG elements, called after each fabric object has been created.\n * Takes as input the original svg element and the generated `FabricObject` as arguments. Used to inspect extra properties not parsed by fabric,\n * or extra custom manipulation\n * @param {Object} [options] Object containing options for parsing\n * @param {String} [options.crossOrigin] crossOrigin setting to use for external resources\n * @param {AbortSignal} [options.signal] handle aborting, see https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal\n * @return {SVGParsingOutput}\n * {@link SVGParsingOutput} also receives `allElements` array as the last argument. This is the full list of svg nodes available in the document.\n * You may want to use it if you are trying to regroup the objects as they were originally grouped in the SVG. ( This was the reason why it was added )\n */\nexport async function parseSVGDocument(\n  doc: Document,\n  reviver?: TSvgReviverCallback,\n  { crossOrigin, signal }: LoadImageOptions = {}\n): Promise<SVGParsingOutput> {\n  if (signal && signal.aborted) {\n    console.log('`options.signal` is in `aborted` state');\n    // this is an unhappy path, we dont care about speed\n    return createEmptyResponse();\n  }\n  const documentElement = doc.documentElement;\n  parseUseDirectives(doc);\n\n  const descendants = Array.from(documentElement.getElementsByTagName('*')),\n    options = {\n      ...applyViewboxTransform(documentElement),\n      crossOrigin,\n      signal,\n    };\n\n  const elements = descendants.filter((el) => {\n    applyViewboxTransform(el);\n    return isValidSvgTag(el) && !hasInvalidAncestor(el); // http://www.w3.org/TR/SVG/struct.html#DefsElement\n  });\n  if (!elements || (elements && !elements.length)) {\n    return {\n      ...createEmptyResponse(),\n      options,\n      allElements: descendants,\n    };\n  }\n  const localClipPaths: Record<string, Element[]> = {};\n  const loaclMasks: Record<string, Element[]> = {}\n  descendants\n    .filter((el) => el.nodeName.replace('svg:', '') === 'clipPath')\n    .forEach((el) => {\n      const id = el.getAttribute('id')!;\n      localClipPaths[id] = Array.from(el.getElementsByTagName('*')).filter(\n        (el) => isValidSvgTag(el)\n      );\n    });\n  descendants\n    .filter((el) => el.nodeName.replace('svg:', '') === 'mask')\n    .forEach((el) => {\n      const id = el.getAttribute('id')!;\n      loaclMasks[id] = Array.from(el.getElementsByTagName('*')).filter(\n        (el) => isValidSvgTag(el)\n      );\n    });\n  // Precedence of rules:   style > class > attribute\n  const elementParser = new ElementsParser(\n    elements,\n    options,\n    reviver,\n    doc,\n    localClipPaths,\n    loaclMasks\n  );\n  const instances = await elementParser.parse();\n  return {\n    objects: instances as any[],\n    elements,\n    options,\n    allElements: descendants,\n  };\n}\n","import { getFabricWindow } from 'fabric';\nimport type { LoadImageOptions } from '../util/misc/objectEnlive';\nimport { parseSVGDocument } from './parseSVGDocument';\nimport type { SVGParsingOutput, TSvgReviverCallback } from './typedefs';\n\nconst initializeCanvas = (fontFamily: string, fontSize: number, fontWeight: string, fontStyle: string): CanvasRenderingContext2D => {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    context.font = `${fontWeight} ${fontStyle} ${fontSize}px ${fontFamily}`;\n    return context;\n};\n\n// Function to measure text width with caching\nconst measureTextWidthWithCache = (context: CanvasRenderingContext2D, text: string, cache: Map<string, number>, fontKey: string): number => {\n    const cacheKey = `${fontKey}-${text}`;\n    if (cache.has(cacheKey)) {\n        return cache.get(cacheKey);\n    } else {\n        const width = context.measureText(text).width;\n        cache.set(cacheKey, width);\n        return width;\n    }\n};\n\nconst detectAndSplitHiddenSpaces = (svgData: string): string => {\n    const cache = new Map();\n    const parser = new DOMParser();\n    const svgDocument = parser.parseFromString(svgData, 'image/svg+xml');\n    const tspanElements = svgDocument.querySelectorAll('tspan');\n\n    tspanElements.forEach(tspan => {\n        const xValues = tspan.getAttribute('x')?.split(' ').map(Number) || [];\n        const textContent = tspan.textContent || '';\n\n        let previousX = xValues[0];\n        const newTspans: HTMLElement[] = [];\n\n        // Extract font properties from the <text> or <tspan> attributes\n        const fontFamily = tspan.closest('text')?.getAttribute('font-family') || 'Arial';\n        const fontSize = parseFloat(tspan.closest('text')?.getAttribute('font-size') || '14');\n        const fontWeight = tspan.closest('text')?.getAttribute('font-weight') || 'normal';\n        const fontStyle = tspan.closest('text')?.getAttribute('font-style') || 'normal';\n\n        // Create a unique key for caching based on the font properties\n        const fontKey = `${fontFamily}-${fontWeight}-${fontStyle}-${fontSize}`;\n\n        // Initialize the canvas context with the font properties\n        const context = initializeCanvas(fontFamily, fontSize, fontWeight, fontStyle);\n\n        let startIdx = 0;\n\n        for (let i = 1; i < xValues.length; i++) {\n            const currentX = xValues[i];\n            const char = textContent[i - 1];\n\n            // Measure the width of the character and space with caching\n            const charWidth = measureTextWidthWithCache(context, char, cache, fontKey);\n            const spaceWidth = measureTextWidthWithCache(context, ' ', cache, fontKey);\n\n            if ((currentX - previousX) > (charWidth + spaceWidth - 0.8)) {\n                // Split the text content into two parts\n                const newTextContent = textContent.slice(startIdx, i);\n\n                // Create a new <tspan> for the text up to the detected space\n                const newTspan = tspan.cloneNode() as HTMLElement;\n                newTspan.textContent = newTextContent;\n\n                // Adjust the x attribute for the new <tspan>\n                newTspan.setAttribute('x', xValues[startIdx].toString());\n\n                // Add the new tspan to the list\n                newTspans.push(newTspan);\n\n                // Update startIdx to the current position\n                startIdx = i;\n            }\n\n            previousX = currentX;\n        }\n\n        // Add the remaining text after the last split\n        if (startIdx < textContent.length) {\n            const newTspan = tspan.cloneNode() as HTMLElement;\n            newTspan.textContent = textContent.slice(startIdx);\n            newTspan.setAttribute('x', xValues[startIdx].toString());\n            newTspans.push(newTspan);\n        }\n\n        // Replace the original <tspan> with the new ones\n        const docFragment = document.createDocumentFragment();\n        newTspans.forEach(newTspan => {\n            docFragment.appendChild(newTspan);\n        });\n        tspan.parentNode?.replaceChild(docFragment, tspan);\n    });\n\n    // Return the modified SVG data as a string\n    return new XMLSerializer().serializeToString(svgDocument);\n};\n\nconst mergeTspans = (svgData: string): string => {\n    const cache = new Map();\n    const parser = new DOMParser();\n    const svgDocument = parser.parseFromString(svgData, 'image/svg+xml');\n    const tspanElements = Array.from(svgDocument.querySelectorAll('tspan'));\n\n    let i = 0;\n    while (i < tspanElements.length - 1) {\n        const currentTspan = tspanElements[i];\n        const nextTspan = tspanElements[i + 1];\n\n        if (isIconOrGlyph(currentTspan.textContent) || isIconOrGlyph(nextTspan.textContent)) {\n            i++;\n            continue; // Skip merging if either tspan contains an icon, glyph, or special character\n        }\n\n        const currentXValues = currentTspan.getAttribute('x')?.split(' ').map(Number) || [];\n        const nextXValues = nextTspan.getAttribute('x')?.split(' ').map(Number) || [];\n\n        const currentText = currentTspan.textContent || '';\n        const nextText = nextTspan.textContent || '';\n\n        const currentLastX = currentXValues[currentXValues.length - 1];\n        const nextFirstX = nextXValues[0];\n\n        const currentTextElement = currentTspan.closest('text');\n        const nextTextElement = nextTspan.closest('text');\n\n        if (!currentTextElement || !nextTextElement) {\n            i++;\n            continue;\n        }\n\n        const currentFontFamily = currentTextElement.getAttribute('font-family') || 'Arial';\n        const currentFontSize = parseFloat(currentTextElement.getAttribute('font-size') || '14');\n        const currentFontWeight = currentTextElement.getAttribute('font-weight') || 'normal';\n        const currentFontStyle = currentTextElement.getAttribute('font-style') || 'normal';\n        const currentY = currentTspan.getAttribute('y') || '';\n        const currentTransform = currentTextElement.getAttribute('transform') || '';\n\n        const nextFontFamily = nextTextElement.getAttribute('font-family') || 'Arial';\n        const nextFontSize = parseFloat(nextTextElement.getAttribute('font-size') || '14');\n        const nextFontWeight = nextTextElement.getAttribute('font-weight') || 'normal';\n        const nextFontStyle = nextTextElement.getAttribute('font-style') || 'normal';\n        const nextY = nextTspan.getAttribute('y') || '';\n        const nextTransform = nextTextElement.getAttribute('transform') || '';\n\n        if (\n            currentFontFamily === nextFontFamily &&\n            currentFontSize === nextFontSize &&\n            currentFontWeight === nextFontWeight &&\n            currentFontStyle === nextFontStyle &&\n            currentY === nextY &&\n            currentTransform === nextTransform\n        ) {\n            const fontKey = `${currentFontFamily}-${currentFontWeight}-${currentFontStyle}-${currentFontSize}`;\n            const context = initializeCanvas(currentFontFamily, currentFontSize, currentFontWeight, currentFontStyle);\n\n            const lastChar = currentText[currentText.length - 1];\n            const spaceWidth = measureTextWidthWithCache(context, ' ', cache, fontKey);\n            const lastCharWidth = measureTextWidthWithCache(context, lastChar, cache, fontKey);\n\n            if ((nextFirstX - currentLastX) < (lastCharWidth + spaceWidth - 1)) {\n                currentTspan.textContent = currentText + nextText;\n                currentTspan.setAttribute('x', [...currentXValues, ...nextXValues].join(' '));\n                nextTspan.parentNode?.removeChild(nextTspan);\n                tspanElements.splice(i + 1, 1); // Remove the merged next tspan from the list\n                // Don't increment i, so we can check the current tspan against the next one after merging\n            } else {\n                i++; // Move to the next tspan\n            }\n        } else {\n            i++; // Move to the next tspan if fonts or other properties do not match\n        }\n    }\n\n    return new XMLSerializer().serializeToString(svgDocument);\n};\n\nconst isIconOrGlyph = (text: string): boolean => {\n    const specialCharacters = new Set(['', '•', '⚙', '✪']); // Add more characters as needed\n\n    for (const char of text) {\n        const codePoint = char.codePointAt(0);\n        if (specialCharacters.has(char)) {\n            return true; // Character is a specific special character\n        }\n        // Check if character is within common icon/glyph ranges\n        const iconGlyphRanges = [\n            [0x2600, 0x26FF], // Miscellaneous Symbols\n            [0x1F300, 0x1F5FF], // Miscellaneous Symbols and Pictographs\n            [0x1F600, 0x1F64F], // Emoticons\n            [0x1F680, 0x1F6FF], // Transport and Map Symbols\n            [0x1F700, 0x1F77F], // Alchemical Symbols\n            [0x1F780, 0x1F7FF], // Geometric Shapes Extended\n            [0x1F800, 0x1F8FF], // Supplemental Arrows-C\n            [0x1F900, 0x1F9FF], // Supplemental Symbols and Pictographs\n            [0x1FA00, 0x1FA6F], // Chess Symbols\n            [0x1FA70, 0x1FAFF], // Symbols and Pictographs Extended-A\n        ];\n\n        for (const [start, end] of iconGlyphRanges) {\n            if (codePoint >= start && codePoint <= end) {\n                return true; // Character is likely an icon or glyph\n            }\n        }\n    }\n    return false; // Text does not contain icons, glyphs, or specific special characters\n};\n\nexport function loadSVGFromString(\n    string: string,\n    reviver?: TSvgReviverCallback,\n    options?: LoadImageOptions\n): Promise<SVGParsingOutput> {\n    const mergeSVGString = mergeTspans(string);\n    const modifiedSVGString = detectAndSplitHiddenSpaces(mergeSVGString);\n    const parser = new (getFabricWindow().DOMParser)(),\n        doc = parser.parseFromString(modifiedSVGString.trim(), 'text/xml');\n\n    // Clone tspan elements into separate text nodes\n    cloneTspansIntoTextNodes(doc);\n    return parseSVGDocument(doc, reviver, options);\n}\n\nfunction cloneTspansIntoTextNodes(doc: Document) {\n    const texts = doc.getElementsByTagName('text');\n    const docFragment = doc.createDocumentFragment();\n\n    for (let i = texts.length - 1; i >= 0; i--) {\n        const textElement = texts[i];\n        const tspans = textElement.getElementsByTagName('tspan');\n\n        if (tspans.length > 1) {\n            for (let j = 0; j < tspans.length; j++) {\n                const tspan = tspans[j];\n                const newText = doc.createElementNS('http://www.w3.org/2000/svg', 'text');\n\n                // Copy attributes from the original text element\n                for (let attr of textElement.attributes) {\n                    newText.setAttribute(attr.name, attr.value);\n                }\n\n                newText.appendChild(tspan.cloneNode(true));\n\n                docFragment.appendChild(newText);\n            }\n\n            textElement.parentNode?.replaceChild(docFragment, textElement);\n        }\n    }\n}\n"],"names":["y","OriginIText","Text","classRegistry","Gradient","Group","Point","el","getFabricWindow"],"mappings":"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"}